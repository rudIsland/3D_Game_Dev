using System.Collections;
using System.Collections.Generic;
using Unity.VisualScripting;
using UnityEngine;

public class Fighter : Enemy
{
    private enum AttackType {
        FlyKick,
        JapCross,
        Kick
    }
    public readonly int _animIDIdle = Animator.StringToHash("Idle"); //서있기
    public readonly int _animIDWalk = Animator.StringToHash("IsWalk"); //걷기
    public readonly int _animIDDectected = Animator.StringToHash("IsDetected"); //탐지
    public readonly int _animIDFightDectected = Animator.StringToHash("FightDecteced"); //공격준비탐지
    public readonly int _animIDFight = Animator.StringToHash("Fight"); //공격모션 범위
    public readonly int _animIDAttackIndex = Animator.StringToHash("AttackIndex"); //공격모션 범위
    public readonly int _animIDAttackTrigger = Animator.StringToHash("AttackTrigger"); //공격모션 범위

    [Header("탐지범위")]
    private float DectectedRange = 7f;
    private float FightDectectedRange = 4.5f;
    private float FightRange = 2f;
    [SerializeField] private bool isDecteced;

    // 공격 관련 타이머 & 범위
    private float jumpAttackTimer = 3f;
    private float FlyKickRange = 1.5f;
    private float JapCrossRange = 1.15f;
    private float KickRange = 1.3f;
    private float HookRange = 1.2f;
    private float JapRange = 1.0f;
    private float LowKickRange = 1.0f;
    private float StepForwardRange = 1.5f;

    private const int ATTACK_JAP = 1;
    private const int ATTACK_LOWKICK = 2;
    private const int ATTACK_HOOK = 3;
    private const int ATTACK_KICK = 4;
    private const int ATTACK_JABCROSS = 5;
    private const int ATTACK_FLYKICK = 6;

    [Header("무기")]
    [SerializeField] private EnemyWeapon LeftHandWeapon; //왼쪽 손
    [SerializeField] private EnemyWeapon RightHandWeapon; //오른쪽 손
    [SerializeField] private EnemyWeapon LeftFootWeapon; //왼쪽 발
    [SerializeField] private EnemyWeapon RightFootWeapon; //오른쪽 발
    protected override void Awake()
    {
        base.Awake(); //자기자신의 컴포넌트 가져오게
    }
    // Start is called before the first frame update
    protected override void Start()
    {
        base.Start();
        OnDeath += HandleDeath; //죽음 델리게이트
        LeftHandWeapon.gameObject.SetActive(false);
        RightHandWeapon.gameObject.SetActive(false);
        LeftFootWeapon.gameObject.SetActive(false);
        RightFootWeapon.gameObject.SetActive(false);
    }

    // Update is called once per frame
    protected override void Update()
    {
        if(stats.IsDead) return; //죽으면 리턴

        UpdateDistanceToPlayer(); //플레이어와의 거리 계산


        behaviorTree?.Evaluate();
    }


    protected override void SetupStats()
    {
        detectRange = DectectedRange; //탐지범위
        attackRange = 1.0f; //공격범위
        moveSpeed = 1.5f; //이동속도
        angularSpeed = 180f; //회전속도

        level.SetLevel(20); //레벨설정

        stats.maxHP = 1000;
        stats.ATK = 40f;
        stats.DEF = 30f;
        statComp.stats.currentHP = statComp.stats.maxHP; //현재 체력설정

        GetComponentInChildren<EnemyGUI>()?.UpdateLevel(); //GUI레벨설정
    }
    /****************************** 트리노드  ************************************/
    protected override void SetupTree()
    {
        // 탐지 트리
        ENode detectTree = new SelectorNode(new List<ENode> {
            new ActionNode(DectectedPlayer),
        });

        ENode attackAndMoveTree = new SelectorNode(new List<ENode> {
             new ActionNode(FightSelector),
             new ActionNode(MoveToPlayer)
        });

        // 전체 트리 구성
        behaviorTree = new SequenceNode(new List<ENode> {
            detectTree,
            attackAndMoveTree
        });
    }

    private ESTATE DectectedPlayer()
    {
        if (GameManager.Instance.playerStateMachine.isDead) return ESTATE.FAILED;

        float distance = enemyMemory.distanceToPlayer;

        isDecteced = distance <= DectectedRange;
        // 탐지 범위 설정
        animator.SetBool(_animIDDectected, isDecteced);
        animator.SetBool(_animIDFightDectected, distance <= FightDectectedRange);
        animator.SetBool(_animIDWalk, (isDecteced && distance >= FightRange));
        animator.SetBool(_animIDFight, distance <= FightRange);

        // 가장 넓은 탐지 거리 내에 들어오면 SUCCESS 반환
        if (distance <= DectectedRange)
        {
            return ESTATE.SUCCESS;
        }

        return ESTATE.FAILED;

    }

    private ESTATE PlayAttack(int attackIndex)
    {
        if (isAttacking) return ESTATE.SUCCESS;

        if (!IsFacingTarget(enemyMemory.player.position))
        {
            RotateTowardsPlayer();
            return ESTATE.RUN;
        }

        isAttacking = true;

        if (agent.enabled && agent.isOnNavMesh)
            agent.isStopped = true;

        if (attackIndex == ATTACK_FLYKICK)
            jumpAttackTimer = 3f;

        animator.SetInteger(_animIDAttackIndex, attackIndex);
        animator.SetTrigger(_animIDAttackTrigger); // 전제: AnyState → StepForward → 공격 상태들로 넘어감

        return ESTATE.SUCCESS;
    }


    private ESTATE FightSelector()
    {
        float flyKickWeight = 0f;
        float japCrossWeight = 1f;
        float hookWeight = 1f;
        float kickWeight = 1f;
        float japWeight = 1f;
        float lowKickWeight = 1f;

        float distance = enemyMemory.distanceToPlayer;

        if (distance <= JapRange)
            japWeight += 10f;

        if (distance <= LowKickRange)
            lowKickWeight += 10f;

        if (distance <= HookRange)
            hookWeight += 10f;

        if (distance <= KickRange)
            kickWeight += 10f;

        if (distance <= JapCrossRange)
            japCrossWeight += 10f;

        if (distance <= FlyKickRange && jumpAttackTimer <= 0f)
            flyKickWeight = 15f;

        float totalWeight = flyKickWeight + japCrossWeight + hookWeight + kickWeight + japWeight + lowKickWeight;
        if (totalWeight <= 0f) return ESTATE.FAILED;

        float roll = Random.Range(0f, totalWeight);

        if (roll <= flyKickWeight)
            return PlayAttack(ATTACK_FLYKICK);

        roll -= flyKickWeight;
        if (roll <= japCrossWeight)
            return PlayAttack(ATTACK_JABCROSS);

        roll -= japCrossWeight;
        if (roll <= hookWeight)
            return PlayAttack(ATTACK_HOOK);

        roll -= hookWeight;
        if (roll <= kickWeight)
            return PlayAttack(ATTACK_KICK);

        roll -= kickWeight;
        if (roll <= lowKickWeight)
            return PlayAttack(ATTACK_LOWKICK);

        return PlayAttack(ATTACK_JAP);
    }


    //이동
    private ESTATE MoveToPlayer()
    {
        if (!isDecteced)
        {
            Debug.Log("[이동] 탐지 실패 → 이동 정지");
            SetAgentStop(true);
            return ESTATE.FAILED;
        }

        // 공격 중엔 이동하지 않음
        if (isAttacking)
        {
            Debug.Log("[이동] 공격 중 → 이동 정지");
            SetAgentStop(true);
            return ESTATE.SUCCESS;
        }

        // 공격 실패 후 이동
        Debug.Log("[이동] 플레이어에게 이동 중");
        SetAgentStop(false);
        agent.SetDestination(enemyMemory.player.position);

        return ESTATE.RUN;
    }

    //공격

    private ESTATE JapCrossAttack()
    {
        // 공격 조건 검사 후 애니메이션 재생
        if (! (JapCrossRange <= enemyMemory.distanceToPlayer))
        {
            Debug.Log("[공격] 잽크로스 공격 실패: 범위 아님");
            return ESTATE.FAILED;
        }

        if (!IsFacingTarget(enemyMemory.player.position))
        {
            Debug.Log("[공격] 잽크로스 공격 회전 중...");
            if (!isAttacking) RotateTowardsPlayer();
            return ESTATE.RUN;
        }

        if (!isAttacking)
        {
            Debug.Log("[공격] 잽크로스 공격 시작");
            NormalAttackingStart(); //원래 없는건데 추가해봄 너무 피격이 쉬워서

            //animator.SetInteger(_animIDAttackIndex, ATTACK_PUNCH);
            //animator.SetTrigger(_animIDAttackTrigger);
        }

        return ESTATE.SUCCESS;
    }

    private ESTATE KickAttack()
    {
        // 공격 조건 검사 후 애니메이션 재생
        if (!(KickRange <= enemyMemory.distanceToPlayer))
        {
            Debug.Log("[공격] 킥 공격 실패: 범위 아님");
            return ESTATE.FAILED;
        }

        if (!IsFacingTarget(enemyMemory.player.position))
        {
            Debug.Log("[공격] 킥 공격 회전 중...");
            if (!isAttacking) RotateTowardsPlayer();
            return ESTATE.RUN;
        }

        if (!isAttacking)
        {
            Debug.Log("[공격] 킥 공격 시작");
            NormalAttackingStart(); //원래 없는건데 추가해봄 너무 피격이 쉬워서

            //animator.SetInteger(_animIDAttackIndex, ATTACK_PUNCH);
            //animator.SetTrigger(_animIDAttackTrigger);
        }
        return ESTATE.SUCCESS;
    }

    private ESTATE FlyKickAttack()
    {
        // 공격 조건 검사 후 애니메이션 재생
        if (!(FlyKickRange <= enemyMemory.distanceToPlayer))
        {
            Debug.Log("[공격] 플라이킥 공격 실패: 범위 아님");
            return ESTATE.FAILED;
        }

        if (!IsFacingTarget(enemyMemory.player.position))
        {
            Debug.Log("[공격] 플라이킥 공격 회전 중...");
            if (!isAttacking) RotateTowardsPlayer();
            return ESTATE.RUN;
        }

        if (!isAttacking)
        {
            Debug.Log("[공격] 플라이킥 공격 시작");
            NormalAttackingStart(); //원래 없는건데 추가해봄 너무 피격이 쉬워서

            //animator.SetInteger(_animIDAttackIndex, ATTACK_PUNCH);
            //animator.SetTrigger(_animIDAttackTrigger);
        }
        return ESTATE.SUCCESS;
    }

    /****************************** HiT & 무기  ************************************/

    private void OffHit()
    {
        isAttacking = false;
        //animator.SetBool(_animIDHit, false);
        //animator.SetBool(_animIDAttack, isAttacking);
    }

    public void OnLeftHandWeapon()
    {
        LeftHandWeapon.gameObject.SetActive(true);
    }
    public void OnRightHandWeapon()
    {
        RightHandWeapon.gameObject.SetActive(true);
    }
    public void OnLeftFootWeapon()
    {
        LeftFootWeapon.gameObject.SetActive(true);
    }
    public void OnRightFootWeapon()
    {
        RightFootWeapon.gameObject.SetActive(true);
    }
    public void OffWeapon()
    {
        LeftHandWeapon.gameObject.SetActive(false);
        RightHandWeapon.gameObject.SetActive(false);
        LeftFootWeapon.gameObject.SetActive(false);
        RightFootWeapon.gameObject.SetActive(false);
    }

    private void NormalAttackingStart()
    {
        isAttacking = true;
        animator.applyRootMotion = true;
        if (agent != null && agent.enabled && agent.isOnNavMesh)
        {
            agent.isStopped = true;
        }
        //animator.SetBool(_animIDAttack, true);
    }

    private void NormalAttackingEnd()
    {
        if (statComp.stats.IsDead) return;

        isAttacking = false;

        if (agent != null && agent.enabled && agent.isOnNavMesh)
        {
            agent.isStopped = false;
            animator.ResetTrigger(_animIDAttackTrigger);
            animator.SetInteger(_animIDAttackIndex, 0);
        }

    }

    /****************************** Agent And 검사 Logic  ************************************/

    private bool IsFacingTarget(Vector3 target)
    {
        Vector3 directionToTarget = (target - transform.position).normalized;
        float dot = Vector3.Dot(transform.forward, directionToTarget);
        return dot > 0.90f; // 0.90 이상이면 거의 정면을 보고 있다고 판단
    }

    private void SetAgentStop(bool stop)
    {
        if (!agent.enabled) return;

        if (agent.isStopped != stop)
            agent.isStopped = stop;
    }

    private void SetAgentRotation(bool enable)
    {
        if (agent.updateRotation != enable)
            agent.updateRotation = enable;
    }

    // 데미지 받기
    public override void ApplyDamage(double damage)
    {
        stats.currentHP -= damage;
        stats.currentHP = Mathf.Max((float)stats.currentHP, 0);

        //if (!isAttacking)
        //{
        //    animator.SetBool(_animIDHit, true);
        //}
        CheckDie();

        statComp.UpdateHPUI();
    }
}
